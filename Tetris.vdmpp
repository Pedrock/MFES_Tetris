class Tetris
/*
	A classe Tetris representa o o modelo principal do jogo, onde se encontram definidas as operações
	 permitidas ao jogador.
*/

types

public GameState = <NotStarted> | <Game> | <GameOver>;

values

public LINES_PER_LEVEL : nat1 = 20;

instance variables

-- Grelha do jogo
public gameGrid : GameGrid := new GameGrid();

-- Tetraminó em jogo
public tetramino : [Tetramino] := nil;

public score : nat := 0;

public level : nat := 0;

public numberOfLines : nat := 0;

public gameState : GameState := <NotStarted>;

inv tetramino = nil or not hasCollision(tetramino.rotationsList(tetramino.rotation), gameGrid.grid, tetramino.x, tetramino.y);

operations

--Início do jogo
public begin : () ==> ()
begin() == (
	gameGrid := new GameGrid();
	tetramino := getRandomTetramino();
	score := 0;
	level := 0;
	numberOfLines := 0;
	gameState := <Game>;
);

public tick : () ==> ()
tick() == (
	if (gameState <> <Game>) then return;
	if not tetraminoHasCollisionInCoords(tetramino.x, tetramino.y - 1) then
		tetramino.y := tetramino.y - 1
	else
		addTetraminoToGrid();
);

public moveRight : () ==> ()
moveRight() == (
	if (gameState <> <Game>) then return;
	if not tetraminoHasCollisionInCoords(tetramino.x + 1, tetramino.y) then
		tetramino.x := tetramino.x + 1;
);

public moveLeft : () ==> ()
moveLeft() == (
	if (gameState <> <Game>) then return;
	if not tetraminoHasCollisionInCoords(tetramino.x - 1, tetramino.y) then
		tetramino.x := tetramino.x - 1;
);

public rotateRight : () ==> ()
rotateRight() == (
	if (gameState <> <Game>) then return;
	tryRotation(tetramino.getRightRotation())
);

public rotateLeft : () ==> ()
rotateLeft() == (
	if (gameState <> <Game>) then return;
	tryRotation(tetramino.getLeftRotation())
);

public hardDrop : () ==> ()
hardDrop() == (
	if (gameState <> <Game>) then return;
	while canMoveDown() do (
		tetramino.y := tetramino.y - 1;
	);
	addTetraminoToGrid()
);

private canMoveDown : () ==> bool
canMoveDown() == (
	return not tetraminoHasCollisionInCoords(tetramino.x, tetramino.y - 1)
);

private addTetraminoToGrid : () ==> ()
addTetraminoToGrid() == (
	gameGrid.addTetramino(tetramino);
	removeCompleteLines();
	let line = gameGrid.grid(GameGrid`HEIGHT) in (
		if exists x in set inds line & line(x) <> <Blank> then (
			gameState := <GameOver>;
			tetramino := nil;
		)
	);
	if gameState = <Game> then
		tetramino := getRandomTetramino();
);

private removeCompleteLines : () ==> ()
removeCompleteLines() == (
	dcl linesRemoved : nat := 0;
	dcl y : nat := 1;
	while (y <= len gameGrid.grid) do (
		let line = gameGrid.grid(y) in (
			if (forall x in set inds line & line(x) <> <Blank>) then (
				gameGrid.removeLine(y);
				linesRemoved := linesRemoved + 1;
				y := y - 1;
			)
		);
		y := y + 1;
	);
	if (linesRemoved > 0) then (
		atomic(
			score := score + calcScore(linesRemoved, level);
			numberOfLines := numberOfLines + linesRemoved;
			level := floor (numberOfLines / LINES_PER_LEVEL)
		);
	)
);

private tryRotation : Tetramino`RotationResult ==> ()
tryRotation(result) ==  (
	if not hasCollision(result.matrix, gameGrid.grid, tetramino.x, tetramino.y) then
			tetramino.rotation := result.rotation
		else if not hasCollision(result.matrix, gameGrid.grid, tetramino.x + 1, tetramino.y) then
		atomic ( -- Right wall kick (http://tetris.wikia.com/wiki/Wall_kick)
			tetramino.rotation := result.rotation;
			tetramino.x := tetramino.x + 1
		)
		else if not hasCollision(result.matrix, gameGrid.grid, tetramino.x - 1, tetramino.y) then
		atomic ( -- Left wall kick
			tetramino.rotation := result.rotation;
			tetramino.x := tetramino.x - 1
		)
);

--Escolha aleatória do tetraminó em jogo
private getRandomTetramino : () ==> Tetramino
getRandomTetramino() == return new Tetramino(MATH`rand(Tetramino`getNumber()-1)+1);
	
-- Verifica se o tetraminó em jogo tem colisão nas coordenadas (x, y)
public tetraminoHasCollisionInCoords : int*int ==> bool
tetraminoHasCollisionInCoords(x, y) == (
	for all tetraminoY in set inds tetramino.getCurrentMatrix() do (
		let line = tetramino.getCurrentMatrix()(tetraminoY) in (
			for all tetraminoX in set inds line do (
				let cellX = x - 1 + tetraminoX, cellY = y + 1 - tetraminoY in (
				if (line(tetraminoX) <> <Blank>) then (
					if cellX < 1 or cellX > GameGrid`WIDTH
						  or cellY < 1 or cellY > GameGrid`HEIGHT
							or gameGrid.getCell(cellX, cellY) <> <Blank>
						then return true
					)
				)
			)
		)
	);
	return false
)
post 
RESULT = hasCollision(tetramino.rotationsList(tetramino.rotation), gameGrid.grid, x, y);


functions

private hasCollision : Tetramino`TetraminoMatrix * GameGrid`Grid * int * int -> bool
hasCollision(tetraminoMatrix, gameGrid, x, y) == (
	exists tetraminoY in set inds tetraminoMatrix &
		exists tetraminoX in set inds tetraminoMatrix(tetraminoY)
			& tetraminoMatrix(tetraminoY)(tetraminoX) <> <Blank> 
			and let cellX = x - 1 + tetraminoX, cellY = y + 1 - tetraminoY in (
						cellX < 1
						or cellX > GameGrid`WIDTH
						or cellY < 1
						or cellY > GameGrid`HEIGHT
						or gameGrid(cellY)(cellX) <> <Blank>
			)
);

private calcScore : nat*nat -> nat
calcScore(lines, level) == (
	if (lines = 0) then 0
	else if (lines = 1) then 40*(level+1)
	else if (lines = 2) then 100*(level+1)
	else if (lines = 3) then 300*(level+1)
	else 1200*(level+1)
)
pre lines <= 4;

end Tetris